import cv2
import pickle
import numpy as np
import os
import csv
import time
from datetime import datetime
import pyttsx3
import RPi.GPIO as GPIO
import requests
from mfrc522 import SimpleMFRC522
from sklearn.neighbors import KNeighborsClassifier

# --- Telegram Config ---
BOT_TOKEN = "8129064480:AAFZZjw7UTUrPgwUW33xu_B51MyJPg3WneY"
CHAT_ID = "1367693706"

# GPIO Setup
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
BUZZER_PIN = 17
LED_WRONG_PIN = 27
LED_ATTENDANCE_PIN = 22

GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.setup(LED_WRONG_PIN, GPIO.OUT)
GPIO.setup(LED_ATTENDANCE_PIN, GPIO.OUT)

GPIO.output(BUZZER_PIN, GPIO.LOW)
GPIO.output(LED_WRONG_PIN, GPIO.LOW)
GPIO.output(LED_ATTENDANCE_PIN, GPIO.LOW)

# TTS
engine = pyttsx3.init()

# RFID
reader = SimpleMFRC522()

# Load Face Data
video = cv2.VideoCapture(0)
if not video.isOpened():
    print("Error: Camera not found.")
    exit()

facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

try:
    with open('data/names.pkl', 'rb') as w:
        LABELS = pickle.load(w)
    with open('data/faces_data.pkl', 'rb') as f:
        FACES = pickle.load(f)
    with open('data/rfid_data.pkl', 'rb') as r:
        RFID_LIST = pickle.load(r)
except Exception as e:
    print("Error loading face data:", e)
    exit()

FACES = np.array(FACES)
if len(FACES) == 0:
    print("No face data found. Please register faces first.")
    exit()
FACES = FACES.reshape(FACES.shape[0], -1)

knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

COL_NAMES = ['NAME', 'RFID', 'DATE', 'TIME']
os.makedirs("Attendance", exist_ok=True)

try:
    while True:
        print("Put Face in Front of Camera")

        ret, frame = video.read()
        if not ret:
            print("Error: Frame not captured.")
            break

        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        faces = facedetect.detectMultiScale(gray, 1.3, 5)

        for (x, y, w, h) in faces:
            crop_img = rgb_frame[y:y+h, x:x+w]
            resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)

            distances, indices = knn.kneighbors(resized_img)
            if distances[0][0] > 100:  # Confidence threshold
                print("Unknown face detected. Confidence too low.")
                GPIO.output(LED_WRONG_PIN, GPIO.HIGH)
                engine.say("Get lost")
                engine.runAndWait()
                GPIO.output(BUZZER_PIN, GPIO.HIGH)
                time.sleep(1)
                GPIO.output(BUZZER_PIN, GPIO.LOW)
                GPIO.output(LED_WRONG_PIN, GPIO.LOW)
                continue

            recognized_name = knn.predict(resized_img)[0]

            print("Recognized:", recognized_name)
            engine.say("Put your RFID Card")
            engine.runAndWait()

            video.release()
            cv2.destroyAllWindows()

            try:
                card_id, card_text = reader.read()
            except Exception as e:
                print("RFID Error:", e)
                time.sleep(2)
                continue

            if recognized_name not in LABELS:
                print("Unknown Face - get lost")
                engine.say("Get lost")
                engine.runAndWait()
                continue

            expected_rfid = RFID_LIST[LABELS.index(recognized_name)]
            if str(card_id) != str(expected_rfid):
                print("Wrong RFID. Please put correct card")
                engine.say("Please put correct card")
                engine.runAndWait()
                GPIO.output(LED_WRONG_PIN, GPIO.HIGH)
                for _ in range(2):
                    GPIO.output(BUZZER_PIN, GPIO.HIGH)
                    time.sleep(1)
                    GPIO.output(BUZZER_PIN, GPIO.LOW)
                    time.sleep(0.5)
                GPIO.output(LED_WRONG_PIN, GPIO.LOW)
                time.sleep(5)
                video = cv2.VideoCapture(0)
                if not video.isOpened():
                    print("Error: Could not reopen camera.")
                    GPIO.cleanup()
                    exit()
                continue

            date_today = datetime.now().strftime("%d-%m-%Y")
            attendance_file = f"Attendance/Attendance_{date_today}.csv"
            file_exists = os.path.isfile(attendance_file)
            attendance_count = 0
            if file_exists:
                with open(attendance_file, "r") as f:
                    reader_csv = csv.reader(f)
                    next(reader_csv)
                    for row in reader_csv:
                        if row[0] == recognized_name and row[1] == str(card_id):
                            attendance_count += 1

            if attendance_count >= 2:
                print("Two time is over, not allowed")
                engine.say("Two time is over, not allowed")
                engine.runAndWait()
                time.sleep(3)
                continue

            timestamp = datetime.now().strftime("%H:%M:%S")
            with open(attendance_file, "a", newline='') as csvfile:
                writer = csv.writer(csvfile)
                if not file_exists:
                    writer.writerow(COL_NAMES)
                writer.writerow([recognized_name, card_id, date_today, timestamp])

            os.makedirs("Attendance/images", exist_ok=True)
            photo_filename = f"Attendance/images/{recognized_name}_{datetime.now().strftime('%H%M%S')}.jpg"
            cv2.imwrite(photo_filename, frame)

            requests.post(f"https://api.telegram.org/bot{BOT_TOKEN}/sendPhoto",
                          files={'photo': open(photo_filename, 'rb')},
                          data={'chat_id': CHAT_ID, 'caption': f"Attendance Marked\nName: {recognized_name}\nDate: {date_today}\nTime: {timestamp}"})

            engine.say("Attendance Taken")
            engine.runAndWait()

            GPIO.output(LED_ATTENDANCE_PIN, GPIO.HIGH)
            GPIO.output(BUZZER_PIN, GPIO.HIGH)
            time.sleep(1)
            GPIO.output(BUZZER_PIN, GPIO.LOW)
            time.sleep(10)
            GPIO.output(LED_ATTENDANCE_PIN, GPIO.LOW)

            video = cv2.VideoCapture(0)
            if not video.isOpened():
                print("Error: Could not reopen camera.")
                GPIO.cleanup()
                exit()

        if 'video' in locals() and video.isOpened():
            cv2.imshow("Frame", frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

except KeyboardInterrupt:
    print("Interrupted by user.")

finally:
    if 'video' in locals():
        video.release()
    cv2.destroyAllWindows()
    GPIO.cleanup()
