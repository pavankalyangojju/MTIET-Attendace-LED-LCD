-------------add_faces_without_RBG-----------------------
import cv2
import pickle
import numpy as np
import os
import RPi.GPIO as GPIO
from mfrc522 import SimpleMFRC522
import time
from RPLCD.i2c import CharLCD

# Initialize LCD
lcd = CharLCD(i2c_expander='PCF8574', address=0x27, port=1, cols=16, rows=2, dotsize=8)

# Display Welcome Message
lcd.clear()
lcd.write_string("HI,Welcome to")
lcd.crlf()
lcd.write_string("AttendanceSystem")
time.sleep(3)
lcd.clear()

# Setup GPIO
GPIO.setwarnings(False)
if GPIO.getmode() is None:
    GPIO.setmode(GPIO.BCM)

# Initialize RFID Reader
reader = SimpleMFRC522()

# Set up GPIO for LED
LED_PIN = 18
GPIO.setup(LED_PIN, GPIO.OUT)
GPIO.output(LED_PIN, GPIO.LOW)

# Open the camera
video = cv2.VideoCapture(0)
if not video.isOpened():
    lcd.write_string("Camera Error!")
    print("Error: Could not open camera.")
    exit()

# Load Haarcascade for face detection
facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# Data storage paths
faces_file = 'data/faces_data.pkl'
rfid_file = 'data/rfid_data.pkl'
names_file = 'data/names.pkl'

# Scan RFID Card
lcd.write_string("Scan your CARD")
print("Scan your RFID card...")

try:
    card_id, card_text = reader.read()
    print(f"RFID Card ID: {card_id}")
    lcd.clear()

    # Check if RFID already exists
    if os.path.exists(rfid_file):
        with open(rfid_file, 'rb') as f:
            stored_rfid = pickle.load(f)

        if card_id in stored_rfid:
            lcd.write_string("Face already")
            lcd.crlf()
            lcd.write_string("registered!")
            print("Your face is already registered, no need again.")
            time.sleep(3)
            lcd.clear()
            GPIO.cleanup()
            exit()

    lcd.write_string("Enter Your Name:")
    name = input("Enter Your Name: ")

except Exception as e:
    lcd.clear()
    lcd.write_string("RFID Error!")
    print(f"RFID Error: {e}")
    exit()

# Display Face Capture Message
lcd.clear()
lcd.write_string("Look at Camera")
lcd.crlf()
lcd.write_string("Stay - light off")
print("Put your face towards the camera and stay until the light turns off...")

# LED ON while capturing face
GPIO.output(LED_PIN, GPIO.HIGH)

faces_data = []
rfid_data = []
names_data = []
captured_face = None

# Record the start time
start_time = time.time()

# Set duration for face capture (30 seconds)
capture_duration = 30  # seconds

while True:
    ret, frame = video.read()

    if not ret:
        print("Error: Could not capture frame.")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)

    for (x, y, w, h) in faces:
        crop_img = frame[y:y+h, x:x+w]              # BGR
        rgb_face = cv2.cvtColor(crop_img, cv2.COLOR_BGR2RGB)  # Convert to RGB
        resized_img = cv2.resize(rgb_face, (50, 50))          # Resize face in RGB format

        if len(faces_data) < 100 and time.time() - start_time < capture_duration:
            faces_data.append(resized_img)
            rfid_data.append(card_id)
            names_data.append(name)
            captured_face = resized_img

        cv2.putText(frame, str(len(faces_data)), (50, 50), cv2.FONT_HERSHEY_COMPLEX, 1, (50, 50, 255), 1)
        cv2.rectangle(frame, (x, y), (x + w, y + h), (50, 50, 255), 1)

    cv2.imshow("Frame", frame)
    k = cv2.waitKey(1)

    if k == ord('q') or time.time() - start_time >= capture_duration:
        break

video.release()
cv2.destroyAllWindows()

GPIO.output(LED_PIN, GPIO.LOW)

lcd.clear()
lcd.write_string("Saving Data...")
print("Saving data...")

faces_data = np.asarray(faces_data).reshape(len(faces_data), 50, 50, 3)

if not os.path.exists(names_file):
    with open(names_file, 'wb') as f:
        pickle.dump(names_data, f)
else:
    with open(names_file, 'rb') as f:
        stored_names = pickle.load(f)
    stored_names.extend(names_data)
    with open(names_file, 'wb') as f:
        pickle.dump(stored_names, f)

if not os.path.exists(rfid_file):
    with open(rfid_file, 'wb') as f:
        pickle.dump(rfid_data, f)
else:
    with open(rfid_file, 'rb') as f:
        stored_rfid = pickle.load(f)
    stored_rfid.extend(rfid_data)
    with open(rfid_file, 'wb') as f:
        pickle.dump(stored_rfid, f)

if not os.path.exists(faces_file):
    with open(faces_file, 'wb') as f:
        pickle.dump(faces_data, f)
else:
    with open(faces_file, 'rb') as f:
        stored_faces = pickle.load(f)
        stored_faces = stored_faces.reshape(-1, 50, 50, 3)

    stored_faces = np.vstack((stored_faces, faces_data))
    with open(faces_file, 'wb') as f:
        pickle.dump(stored_faces, f)

lcd.clear()
lcd.write_string("Data Saved")
lcd.crlf()
lcd.write_string("Successfully!")
print("Data saved successfully!")

GPIO.cleanup()

--------------------------------------------------------------------------code end---------------------
-------------code-for-testing-py------------------------------------------

import cv2
import pickle
import numpy as np
import os
import csv
import time
from datetime import datetime
import pyttsx3
import RPi.GPIO as GPIO
import smbus2
import requests
from mfrc522 import SimpleMFRC522
from sklearn.neighbors import KNeighborsClassifier

# --- Telegram Config ---
BOT_TOKEN = "8129064480:AAFZZjw7UTUrPgwUW33xu_B51MyJPg3WneY"
CHAT_ID = "1367693706"

# GPIO Setup
GPIO.setmode(GPIO.BCM)
BUZZER_PIN = 17
LED_WRONG_PIN = 27
LED_ATTENDANCE_PIN = 22

GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.setup(LED_WRONG_PIN, GPIO.OUT)
GPIO.setup(LED_ATTENDANCE_PIN, GPIO.OUT)

GPIO.output(BUZZER_PIN, GPIO.LOW)
GPIO.output(LED_WRONG_PIN, GPIO.LOW)
GPIO.output(LED_ATTENDANCE_PIN, GPIO.LOW)

# TTS
engine = pyttsx3.init()

# RFID
reader = SimpleMFRC522()

# Load Face Data
video = cv2.VideoCapture(0)
if not video.isOpened():
    print("Error: Camera not found.")
    exit()

facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

try:
    with open('data/names.pkl', 'rb') as w:
        LABELS = pickle.load(w)
    with open('data/faces_data.pkl', 'rb') as f:
        FACES = pickle.load(f)
    with open('data/rfid_data.pkl', 'rb') as r:
        RFID_LIST = pickle.load(r)
except Exception as e:
    print("Error loading face data:", e)
    exit()

FACES = np.array(FACES).reshape(FACES.shape[0], -1)
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

COL_NAMES = ['NAME', 'RFID', 'DATE', 'TIME']
os.makedirs("Attendance", exist_ok=True)

try:
    while True:
        print("Put Face in Front of Camera")

        ret, frame = video.read()
        if not ret:
            print("Error: Frame not captured.")
            break

        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        faces = facedetect.detectMultiScale(gray, 1.3, 5)

        for (x, y, w, h) in faces:
            crop_img = rgb_frame[y:y+h, x:x+w]  # use RGB face
            resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)

            try:
                output = knn.predict(resized_img)
                recognized_name = output[0]
            except Exception as e:
                print("Unknown face detected. Message: get lost")
                GPIO.output(LED_WRONG_PIN, GPIO.HIGH)
                engine.say("Get lost")
                engine.runAndWait()
                GPIO.output(BUZZER_PIN, GPIO.HIGH)
                time.sleep(1)
                GPIO.output(BUZZER_PIN, GPIO.LOW)
                GPIO.output(LED_WRONG_PIN, GPIO.LOW)
                continue

            print("Recognized:", recognized_name)
            engine.say("Put your RFID Card")
            engine.runAndWait()

            video.release()
            cv2.destroyAllWindows()

            try:
                card_id, card_text = reader.read()
            except Exception as e:
                print("RFID Error:", e)
                time.sleep(2)
                continue

            if recognized_name not in LABELS:
                print("Unknown Face - get lost")
                engine.say("Get lost")
                engine.runAndWait()
                continue

            expected_rfid = RFID_LIST[LABELS.index(recognized_name)]
            if str(card_id) != str(expected_rfid):
                print("Wrong RFID. Please put correct card")
                engine.say("Please put correct card")
                engine.runAndWait()
                GPIO.output(LED_WRONG_PIN, GPIO.HIGH)
                for _ in range(2):
                    GPIO.output(BUZZER_PIN, GPIO.HIGH)
                    time.sleep(1)
                    GPIO.output(BUZZER_PIN, GPIO.LOW)
                    time.sleep(0.5)
                GPIO.output(LED_WRONG_PIN, GPIO.LOW)
                time.sleep(5)
                video = cv2.VideoCapture(0)
                if not video.isOpened():
                    print("Error: Could not reopen camera.")
                    GPIO.cleanup()
                    exit()
                continue

            date_today = datetime.now().strftime("%d-%m-%Y")
            attendance_file = f"Attendance/Attendance_{date_today}.csv"
            file_exists = os.path.isfile(attendance_file)
            attendance_count = 0
            if file_exists:
                with open(attendance_file, "r") as f:
                    reader_csv = csv.reader(f)
                    next(reader_csv)
                    for row in reader_csv:
                        if row[0] == recognized_name and row[1] == str(card_id):
                            attendance_count += 1

            if attendance_count >= 2:
                print("Two time is over, not allowed")
                engine.say("Two time is over, not allowed")
                engine.runAndWait()
                time.sleep(3)
                continue

            timestamp = datetime.now().strftime("%H:%M:%S")
            with open(attendance_file, "a", newline='') as csvfile:
                writer = csv.writer(csvfile)
                if not file_exists:
                    writer.writerow(COL_NAMES)
                writer.writerow([recognized_name, card_id, date_today, timestamp])

            os.makedirs("Attendance/images", exist_ok=True)
            photo_filename = f"Attendance/images/{recognized_name}_{datetime.now().strftime('%H%M%S')}.jpg"
            cv2.imwrite(photo_filename, frame)

            requests.post(f"https://api.telegram.org/bot{BOT_TOKEN}/sendPhoto", 
                          files={'photo': open(photo_filename, 'rb')}, 
                          data={'chat_id': CHAT_ID, 'caption': f"Attendance Marked\nName: {recognized_name}\nDate: {date_today}\nTime: {timestamp}"})

            engine.say("Attendance Taken")
            engine.runAndWait()

            GPIO.output(LED_ATTENDANCE_PIN, GPIO.HIGH)
            GPIO.output(BUZZER_PIN, GPIO.HIGH)
            time.sleep(1)
            GPIO.output(BUZZER_PIN, GPIO.LOW)
            time.sleep(10)
            GPIO.output(LED_ATTENDANCE_PIN, GPIO.LOW)

            video = cv2.VideoCapture(0)
            if not video.isOpened():
                print("Error: Could not reopen camera.")
                GPIO.cleanup()
                exit()

        if 'video' in locals() and video.isOpened():
            cv2.imshow("Frame", frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

except KeyboardInterrupt:
    print("Interrupted by user.")

finally:
    if 'video' in locals():
        video.release()
    cv2.destroyAllWindows()
    GPIO.cleanup()
------------------------------------code-end----------------------------------
